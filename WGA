#!/usr/bin/env perl 
use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use FindBin '$Bin';

# Takes two genome assemblies (A & B) in FASTA format and computes a Whole-Genome Alignment (WGA). 
# Returns:
# 1) TSV file matching coordinates from A to B 
# 2) LOG file (text) with WGA stats
# 3) PDF file with dotplot of WGA for quality control

# Bruno Contreras Moreira, Ruben Sancho EEAD-CSIC 2024

# external binaries assumed to be available, edit if non-standard locations
my $GZIPEXE  = 'gzip'; 
my $BZIP2EXE = 'bzip2';

# binaries that should be installed with make 
my $GNUPLOTEXE = "$Bin/lib/gnuplot-5.2.8/src/gnuplot";
my $CGALNEXE   = "$Bin/lib/Cgaln/Cgaln";
my $REDEXE     = "$Bin/lib/Red/bin/Red";
my $RED2ENS    = "$Bin/utils/Red2Ensembl.py";

my %opts;
my ($fileA, $fileB, $minlenMb) = ('', '', 1.0);
my ($softmask, $WGA_params) = (1, '-X12000');
my ($root, $outTSVfile, $outLOGfile, $outPDFfile);

getopts('hcmp:l:A:B:', \%opts);

if(($opts{'h'})||(scalar(keys(%opts))==0))
{
  print "\nusage: $0 [options]\n\n";
  print "-h this message\n";
  print "-A FASTA file of genome A             (example: -A speciesA.fna[.gz])\n";
  print "-B FASTA file of genome B             (example: -B speciesB.fna[.gz])\n";
  print "-l min contig length [Mb]             (optional, default: -l 1)\n";
  print "-m FASTA files already soft-masked    (optional, default: masked with Red\n";
  print "-p parameters for WGA Cgaln algorithm (optional, default: -p '$WGA_params')\n";
  print "-c print credits and checks install   (recommended)\n";
  exit(0);
}

if(defined($opts{'c'})) {

  #print "\nPrimary citation:\n \n";
  print "\nThis software uses external algorithms, please cite them accordingly:\n";
  print " Cgaln https://doi.org/10.1186/1471-2105-11-224\n";
  print " Red https://doi.org/10.1186/s12859-015-0654-5\n";
  print " Red2Ensembl.py https://doi.org/10.1002/tpg2.20143\n";
  print " gnuplot http://www.gnuplot.info\n";

  # check all binaries needed by this program and print diagnostic info
  foreach my $exe ($GNUPLOTEXE, $CGALNEXE, $REDEXE) { 
    if(`$exe -h 2>&1` !~ /usage/i && `$exe -h 2>&1` !~ /input/i) { 
      print "# ERROR: $exe not correctly installed; please run 'make'\n";
    }
  }

  exit(0);
}

if(!defined($opts{'A'})) {
  die "# ERROR: need FASTA file of genome A (-A)\n";
} else {
  $fileA = $opts{'A'}
}

if(!defined($opts{'B'})) {
  die "# ERROR: need FASTA file of genome B (-B)\n";
} else {
  $fileB = $opts{'B'}
}

$root = basename($fileA) .'.'. basename($fileA) . $WGA_params;
$outTSVfile = $root . '.tsv';
$outLOGfile = $root . '.log';
$outPDFfile = $root . '.pdf';

if(defined($opts{'l'}) && $opts{'l'} >= 0) {
  $minlenMb = $opts{'l'}
}

if(defined($opts{'m'})) {
  $softmask = 0
}

if(defined($opts{'p'})) {
  $WGA_params = $opts{'p'}
}

warn "# $0 -A $fileA -B $fileB -l $minlenMb -m $softmask -p $WGA_params\n\n";

######################################################

# 1) foreach FASTA file filter out short sequences, take returned temp file
my $filtA = filter_FASTA_sequences( $fileA, $minlenMb, $GZIPEXE, $BZIP2EXE );
my $filtB = filter_FASTA_sequences( $fileB, $minlenMb, $GZIPEXE, $BZIP2EXE );

# 2) mask filtered FASTA files if required



# 3) compute WGA

#/Cgaln/maketable Bstacei_2.1.softmasked.bedtools.vcf2alignment.fna
#/Cgaln/maketable Bdistachyon_556_v3.0.softmasked.vcf2alignment.fna
#/Cgaln/Cgaln Bdistachyon_556_v3.0.softmasked.vcf2alignment.fna Bstacei_2.1.softmasked.bedtools.vcf2alignment.fna -o Bdistachyon.Bstacei2.1.cgaln.fna -r -X12000 -fc -cons -otype2 &
#/Cgaln/Cgaln Bdistachyon_556_v3.0.softmasked.vcf2alignment.fna Bstacei_2.1.softmasked.bedtools.vcf2alignment.fna -o Bdistachyon.Bstacei2.1.cgaln.dot -r -X12000 -fc -cons

## MAPCOORDS (script in: /home/rsancho/01_vcf2alligment_2023_24/00_vcf2aligment_codes_and_test/vcf2alignment/utils/mapcoords.pl
#nohup /home/rsancho/01_vcf2alligment_2023_24/00_vcf2aligment_codes_and_test/vcf2alignment/utils/mapcoords.pl \
#Bdistachyon.Bstacei2.1.cgaln.fna.gz \
#Bdistachyon_556_v3.0.softmasked.vcf2alignment.fna \
#Bstacei_2.1.softmasked.bedtools.vcf2alignment.fna \
# > Bdistachyon.Bstacei2.1.coords.tsv 2> Bdistachyon.Bstacei2.1.coords.log &

# 4) produce dotplot in PDF format (require make install)


#
# gnuplot -h
# Usage: gnuplot [OPTION] ... [FILE]
#for X11 options see 'help X11->command-line-options'
#  -V, --version
#  -h, --help
#  -p  --persist
#  -s  --slow
#  -d  --default-settings
#  -c  scriptfile ARG1 ARG2 ... 
#  -e  "command1; command2; ..."
#gnuplot 5.2 patchlevel 8

#
#gnuplot
#gnuplot> plot "Bdistachyon.Bstacei2.1.cgaln.dot" with lines
## Convert to png or pdf
#gnuplot
#set terminal pdf
#set output "Bdistachyon.Bstacei2.1.cgaln.pdf"
#plot "Bdistachyon.Bstacei2.1.cgaln.dot" with lines
#unset output




# Takes 4 params:
# i)   path to FASTA file  (string)
# ii)  min sequence length (float, in Mb)
# iii) path to GZIP executable
# iv)  path to BZIP2 executable
# Returns:
# i) path to FASTA file with long sequences
sub filter_FASTA_sequences {
  
  my ( $infile, $min_length_Mb, $gzipexe, $bzip2exe ) = @_;

  my (%FASTA,@ids,$magic,$root,$name,$seq,$seqid,$length);
  my ($n_of_sequences, $n_filtered_sequences) = (0, 0);

  # check input file format and open it accordingly
  open(INFILE,$infile) || die "# filter_FASTA_sequences: cannot read $infile, exit\n";
  sysread(INFILE,$magic,2);
  close(INFILE);

  if($infile =~ /\.gz$/ || $magic eq "\x1f\x8b") # GZIP compressed input
  {
    if(!open(FASTA,"$gzipexe -dc $infile |"))
    {
      die "# filter_FASTA_sequences: cannot read GZIP compressed $infile $!\n"
        ."# please check gzip is installed\n";

    } else {
      $root = $infile;
      $root =~ s/\.gz//;      
    }
  }
  elsif($infile =~ /\.bz2$/ || $magic eq "BZ") # BZIP2 compressed input
  {
    if(!open(FASTA,"$bzip2exe -dc $infile |"))
    {
      die "# filter_FASTA_sequences: cannot read BZIP2 compressed $infile $!\n"
        ."# please check bzip2 is installed\n";

    } else {
      $root = $infile;
      $root =~ s/\.bz2//;                 
    }
  }
  else { 
    open(FASTA,"<$infile") || die "# filter_FASTA_sequences: cannot read $infile $!\n"; 
    $root = $infile;
  }

  while(<FASTA>) {
    if(/^\>(\S+)/) {
      $name = $1;
      $n_of_sequences++;
      $seqid = $n_of_sequences;
      $FASTA{$seqid}{'NAME'} = $name;
      push(@ids,$seqid);

    } else {
      s/[\s|\n]//g;
      $FASTA{$seqid}{'SEQ'} .= $_;
    }
  }

  close(FASTA);

  # create file with long sequences 
  my $filtfile = $root . '.filt';
  open(FILT,">",$filtfile) || die "# filter_FASTA_sequences: cannot create $filtfile $!\n";

  foreach $seqid (@ids) {

    $length = length($FASTA{$seqid}{'SEQ'});

    if($length >= $min_length_Mb * 1_000_000) { 
      print "# filter_FASTA_sequences: [passed $length bp] $FASTA{$seqid}{'NAME'}\n";
      print FILT ">$FASTA{$seqid}{'NAME'}\n$FASTA{$seqid}{'SEQ'}\n";

    } else {
      print "# filter_FASTA_sequences: [skipped $length bp] $FASTA{$seqid}{'NAME'}\n";
    }
  }

  close(FILT);

  return $filtfile
}

#!/usr/bin/env perl 
use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use FindBin '$Bin';
use File::Temp qw/ tempdir /;

# Takes two genome assemblies (A & B) in FASTA format and computes a Whole-Genome Alignment (WGA). 
# Returns:
# 1) TSV file matching coordinates from A to B 
# 2) LOG file (text) with WGA stats
# 3) PDF file with dotplot of WGA for quality control

# Bruno Contreras Moreira, Ruben Sancho EEAD-CSIC 2024

# external binaries assumed to be available, edit if non-standard locations
my $GZIPEXE    = 'gzip'; 
my $BZIP2EXE   = 'bzip2';
my $GNUPLOTEXE = "gnuplot";

# binaries that should be installed with make 
my $CGALNEXE   = "$Bin/lib/Cgaln/Cgaln";
my $CINDEXEXE  = "$Bin/lib/Cgaln/maketable";
my $REDEXE     = "$Bin/lib/Red/bin/Red";
my $RED2ENS    = "$Bin/utils/Red2Ensembl.py";
my $MAPCOORDS  = "$Bin/utils/mapcoords.pl";

my %opts;
my ($fileA, $fileB, $minlenMb, $ncores, $softmask) = ('', '', 1.0, 4, 1);
my ($WGA_Cgaln_params, $WGA_index_params) = ('-X12000', '-K11 -BS10000');
my ($root, $cmd, $tempdirA, $tempdirB);
my ($WGAfile, $WGAdotfile, $WGAscriptfile);
my ($outTSVfile, $outLOGfile, $outPDFfile);

getopts('hcmn:I:C:l:A:B:', \%opts);

if(($opts{'h'})||(scalar(keys(%opts))==0))
{
  print "\nusage: $0 [options]\n\n";
  print "-h this message\n";
  print "-A FASTA file of genome A             (example: -A speciesA.fna[.gz])\n";
  print "-B FASTA file of genome B             (example: -B speciesB.fna[.gz])\n";
  print "-l min contig length [Mbp]            (optional, default: -l $minlenMb)\n";
  print "-m FASTA files already soft-masked    (optional, default: masked with Red\n";
  print "-n number of cores while masking      (optional, default: $ncores\n";
  print "-C parameters for Cgaln aligner       (optional, default: -C '$WGA_Cgaln_params')\n";
  print "-I parameters for Cgaln indexer       (optional, default: -I '$WGA_index_params')\n";
  print "-c print credits and checks install   (recommended)\n";
  exit(0);
}

if(defined($opts{'c'})) {

  #print "\nPrimary citation:\n \n";
  print "\nThis software uses external algorithms, please cite them accordingly:\n";
  print " Cgaln https://doi.org/10.1186/1471-2105-11-224\n";
  print " Red https://doi.org/10.1186/s12859-015-0654-5\n";
  print " Red2Ensembl https://doi.org/10.1002/tpg2.20143\n\n";

  # check all binaries needed by this program and print diagnostic info
  foreach my $exe ($CGALNEXE, $REDEXE, $RED2ENS, $MAPCOORDS) { 
    if(`$exe -h 2>&1` !~ /usage/i && `$exe -h 2>&1` !~ /input/i) { 
      print "# ERROR: $exe not correctly installed; please run 'make'\n";
    }
  }

  exit(0);
}

if(!defined($opts{'A'})) {
  die "# ERROR: need FASTA file of genome A (-A)\n";
} else {
  $fileA = $opts{'A'}
}

if(!defined($opts{'B'})) {
  die "# ERROR: need FASTA file of genome B (-B)\n";
} else {
  $fileB = $opts{'B'}
}

if(defined($opts{'l'}) && $opts{'l'} >= 0 && $opts{'l'} < 1000) {
  $minlenMb = $opts{'l'}
}

if(defined($opts{'n'}) && $opts{'n'} >= 0) {
  $ncores = $opts{'n'}
}

if(defined($opts{'m'})) {
  $softmask = 0
}

if(defined($opts{'I'})) {
  $WGA_index_params = $opts{'I'}
}

if(defined($opts{'C'})) {
  $WGA_Cgaln_params = $opts{'C'}
}

$root = basename($fileA) .'.'. basename($fileA) . $WGA_index_params . '_' . $WGA_Cgaln_params;
$root =~ s/\s+/_/g;

warn "## $0 -A $fileA -B $fileB -l $minlenMb -m $softmask -I $WGA_index_params -C $WGA_Cgaln_params -n $ncores\n\n";
warn "## root: $root\n\n";

######################################################

# 1) foreach FASTA file filter out short sequences, take returned temp file
my $filtA = filter_FASTA_sequences( $fileA, $minlenMb, $GZIPEXE, $BZIP2EXE );
my $filtB = filter_FASTA_sequences( $fileB, $minlenMb, $GZIPEXE, $BZIP2EXE );

# 2) mask filtered FASTA files if required
my $maskA = $fileA . '.sm.fasta';     
my $maskB = $fileB . '.sm.fasta';

if($softmask == 1) {

  print "\n## soft-masking filtered sequences\n\n";

  if(!-s $maskA) {  
    $tempdirA = tempdir( CLEANUP => 1 );
    $cmd = "$RED2ENS --cor $ncores --msk_file $maskA $filtA $tempdirA";
    system("$cmd");
    if($? != 0) {
      die "# EXIT: failed while soft-masking ($cmd)\n";
    }
  }

  if(!-s $maskB) {
    $tempdirB = tempdir( CLEANUP => 1 );
    $cmd = "$RED2ENS --cor $ncores --msk_file $maskB $filtB $tempdirB";
    system("$cmd");
    if($? != 0) {
      die "# EXIT: failed while soft-masking ($cmd)\n";
    }
  }

} else {
  $maskA = $filtA;
  $maskB = $filtB;  
}

# 3) compute WGA, by default maketable & Cgaln are used, which create a folder named 'CgalnTable'

print "\n## indexing masked, filtered sequences\n\n";

# 3.0) clean previous files
system("rm -rf CgalnTable");

# 3.1) compute indexes of filtered sequences
$cmd = "$CINDEXEXE $WGA_index_params $maskA";
system("$cmd");
if($? != 0) {
  die "# EXIT: failed while indexing ($cmd)\n";
}

$cmd = "$CINDEXEXE $WGA_index_params $maskB";
system("$cmd");
if($? != 0) {
  die "# EXIT: failed while indexing ($cmd)\n";
}

# 3.2) compute Whole Genome Alignments of indexed sequences

print "\n## computing and plotting Whole Genome Alignment\n\n";

$WGAfile    = $root . '.Cgaln.fasta';
$WGAdotfile = $root . '.Cgaln.dot'; 

$cmd = "$CGALNEXE $maskA $maskB -o $WGAfile $WGA_Cgaln_params -r -fc -cons -otype2";
system("$cmd");
if($? != 0) {
  die "# EXIT: failed while aligning ($cmd)\n";
}

$cmd = "$CGALNEXE $maskA $maskB -o $WGAdotfile $WGA_Cgaln_params -r -fc -cons -otype0";
system("$cmd");
if($? != 0) {
  die "# EXIT: failed while aligning ($cmd)\n";
}

# 3.3) export dotplot to PDF for visual inspection and parameter tweaking

$WGAscriptfile = $root . '.Cgaln.dot.script';
$outPDFfile    = $root . '.Cgaln.dot.pdf';

open(SCRIPT,">",$WGAscriptfile) || die "# cannot create $WGAscriptfile $!\n";

print SCRIPT<<"END"; 
set terminal pdf
set grid
set output "$outPDFfile"
plot "$WGAdotfile" with lines
unset output
exit
END

close(SCRIPT);

$cmd = "$GNUPLOTEXE -c $WGAscriptfile";
system("$cmd");
if($? != 0) {
  warn "# WARNING: failed while exporting dotplot to PDF ($cmd)\n";
  warn "# WARNING: you need to install GNUPLOT ie \$ sudo apt install gnuplot\n\n";
  $outPDFfile = "(failed, need to install GNUPLOT)\n"; 
}

# 3.4) convert WGA to TSV 

print "\n## converting Whole Genome Alignment to TSV\n\n";

$outTSVfile = $root . '.tsv';
$outLOGfile = $root . '.coords.log';

$cmd = "$MAPCOORDS $WGAfile $maskA $maskB > $outTSVfile 2> $outLOGfile";
system("$cmd");
if($? != 0) {
  die "# EXIT: failed while converting to TSV ($cmd)\n";
}

print "## output files:\n\n";
print "# TSV: $outTSVfile\n";
print "# LOG: $outLOGfile\n";
print "# PDF: $outPDFfile\n\n";






# Takes 4 params:
# i)   path to FASTA file  (string)
# ii)  min sequence length (float, in Mbp)
# iii) path to GZIP executable
# iv)  path to BZIP2 executable
# Returns:
# i) path to FASTA file with long sequences
sub filter_FASTA_sequences {
  
  my ( $infile, $min_length_Mb, $gzipexe, $bzip2exe ) = @_;

  my (%FASTA,@ids,$magic,$root,$name,$seq,$seqid,$length);
  my ($n_of_sequences, $n_filtered_sequences) = (0, 0);

  # check input file format and open it accordingly
  open(INFILE,$infile) || die "# filter_FASTA_sequences: cannot read $infile, exit\n";
  sysread(INFILE,$magic,2);
  close(INFILE);

  if($infile =~ /\.gz$/ || $magic eq "\x1f\x8b") {  # GZIP compressed input
    if(!open(FASTA,"$gzipexe -dc $infile |")) {
      die "# filter_FASTA_sequences: cannot read GZIP compressed $infile $!\n"
        ."# please check gzip is installed\n";

    } else {
      $root = $infile;
      $root =~ s/\.gz//;      
    }
  }
  elsif($infile =~ /\.bz2$/ || $magic eq "BZ") {   # BZIP2 compressed input
    if(!open(FASTA,"$bzip2exe -dc $infile |")) {
      die "# filter_FASTA_sequences: cannot read BZIP2 compressed $infile $!\n"
        ."# please check bzip2 is installed\n";

    } else {
      $root = $infile;
      $root =~ s/\.bz2//;                 
    }
  }
  else { 
    open(FASTA,"<$infile") || die "# filter_FASTA_sequences: cannot read $infile $!\n"; 
    $root = $infile;
  }

  while(<FASTA>) {
    if(/^\>(\S+)/) {
      $name = $1;
      $n_of_sequences++;
      $seqid = $n_of_sequences;
      $FASTA{$seqid}{'NAME'} = $name;
      push(@ids,$seqid);

    } else {
      s/[\s|\n]//g;
      $FASTA{$seqid}{'SEQ'} .= $_;
    }
  }

  close(FASTA);

  # create file with long sequences 
  my $filtfile = $root . ".filt$min_length_Mb.fasta";
  open(FILT,">",$filtfile) || die "# filter_FASTA_sequences: cannot create $filtfile $!\n";

  foreach $seqid (@ids) {

    $length = length($FASTA{$seqid}{'SEQ'});

    if($length >= $min_length_Mb * 1_000_000) { 
      print "# filter_FASTA_sequences: [passed $length bp] $FASTA{$seqid}{'NAME'}\n";
      print FILT ">$FASTA{$seqid}{'NAME'}\n$FASTA{$seqid}{'SEQ'}\n";

    } else {
      print "# filter_FASTA_sequences: [skipped $length bp] $FASTA{$seqid}{'NAME'}\n";
    }
  }

  close(FILT);

  return $filtfile
}
